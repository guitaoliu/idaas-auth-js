# Self-Hosted Authentication Examples

This document provides complete examples for building your own login UI using the `IdaasClient.rba` and `IdaasClient.auth` facades. These examples demonstrate the request-submit-poll lifecycle for popular authenticator types.

## Prerequisites

- Review the [Quickstart guide](quickstart.md) for SDK installation and basic client initialization
- Understand the [Risk-Based Authentication Guide](guides/rba.md) for the underlying transaction flow
- See the [Convenience Auth Guide](guides/auth.md) for simplified helper methods

---

## Authentication Types Overview

The following authentication types are supported by the SDK. Each has different use cases, security levels, and user experiences:

### Knowledge-Based

- **Password** - Traditional username and password authentication
- **Grid Card** - User provides values from specific coordinates on a pre-printed grid card
- **KBA (Knowledge-Based Authentication)** - User answers personal security questions
- **Temporary Access Code** - One-time code provided by an administrator for account recovery or initial setup

### Possession-Based

- **OTP (One-Time Password)** - Time-based or event-based codes delivered via SMS, email, voice, WeChat, or WhatsApp
- **Soft Token** - TOTP codes generated by a mobile authenticator app (e.g., Entrust Identity Mobile)
- **Soft Token Push** - Push notification to user's mobile device for approval/denial
- **Smart Credential Push** - Enhanced push authentication with transaction context and mutual challenge support

### Biometric-Based

- **Passkey (WebAuthn/FIDO2)** - Passwordless authentication using platform authenticators (Face ID, Touch ID, Windows Hello) or security keys
- **Face Biometrics** - Facial recognition authentication powered by Onfido SDK

### Link-Based

- **Magic Link** - One-click authentication link sent to user's email address

### Multi-Factor

- **PASSWORD_AND_SECONDFACTOR** - Combines password with a second authentication method (OTP, soft token, etc.)

---

## OTP (SMS/Email/TOTP)

**Description:** One-Time Password authentication delivers a time-sensitive numeric code to the user through their chosen delivery method. The user enters this code to complete authentication.

**Use cases:**

- Step-up authentication for sensitive operations
- Secondary factor in multi-factor authentication
- Password reset verification
- Account registration verification

```typescript
async function startOtp(userId: string) {
  try {
    const challenge = await idaas.auth.otp(userId, {
      otpDeliveryType: "SMS",
      otpDeliveryAttribute: "work-phone"
    });

    // Prompt user for the code they received
    const code = (document.getElementById("otp-input") as HTMLInputElement).value;

    await idaas.auth.submit({ response: code });

    console.log("OTP authentication complete!");
  } catch (error) {
    console.error("OTP authentication failed", error);
  }
}
```

---

## Passkey (WebAuthn)

**Description:** Passkey authentication leverages WebAuthn/FIDO2 standards to enable passwordless login using biometrics (Face ID, Touch ID, Windows Hello) or hardware security keys. Supports both user-specific and discoverable (usernameless) credentials.

**Use cases:**

- Passwordless primary authentication
- High-security applications requiring phishing-resistant authentication
- Modern user experience with biometric convenience
- Compliance with FIDO2 security standards

```typescript
async function startPasskey(userId?: string) {
  try {
    const result = await idaas.auth.passkey(userId);

    if (result?.authenticationCompleted) {
      console.log("Passkey authentication complete!");
    }
  } catch (error) {
    console.error("Passkey authentication failed", error);
  }
}
```

- Omit `userId` for discoverable credentials.
- Requires HTTPS and WebAuthn support.

---

## Soft token push with mutual challenge

**Description:** Soft token push sends a push notification to the user's registered mobile device (e.g., Entrust Identity Mobile app). The user approves or denies the authentication attempt. Mutual challenge displays a code in both the app and browser that the user must verify to prevent man-in-the-middle attacks.

**Use cases:**

- Convenient multi-factor authentication
- Step-up authentication with visual verification
- High-security transactions requiring user approval
- Mobile-first authentication strategies

```typescript
async function startSoftTokenPush(userId: string) {
  try {
    const initial = await idaas.auth.softToken(userId, {
      push: true,
      mutualChallenge: true
    });

    if (initial.pushMutualChallenge) {
      console.log("Challenge:", initial.pushMutualChallenge);
    }

    const final = await idaas.auth.poll();

    if (final.authenticationCompleted) {
      console.log("Soft token push approved!");
    } else {
      console.log("Soft token push did not complete.");
    }
  } catch (error) {
    console.error("Soft token push failed", error);
  }
}
```

---

## Grid authentication

**Description:** Grid card authentication requires users to reference a physical or digital grid card containing a grid of alphanumeric values. The system prompts for values at specific coordinates (e.g., "A3", "D7"), which the user reads from their card and enters.

**Use cases:**

- Banking and financial services security
- Legacy system integration where grid cards are already deployed
- Scenarios where mobile devices are prohibited or unavailable
- Secondary authentication factor for high-value transactions

```typescript
async function startGrid(userId: string) {
  try {
    const challenge = await idaas.auth.grid(userId);

    // Display challenge.gridChallenge.challenge (e.g., [{ row: "A", column: 3 }, ...])
    const answers = collectGridAnswersFromForm(); // your UI collects answers in order

    const final = await idaas.auth.submit({ response: answers });

    if (final.authenticationCompleted) {
      console.log("Grid challenge satisfied!");
    }
  } catch (error) {
    console.error("Grid authentication failed", error);
  }
}
```

---

## Knowledge-based authentication (KBA)

**Description:** Knowledge-based authentication presents users with security questions they configured during account setup (e.g., "What is your mother's maiden name?", "What was your first pet's name?"). Users must correctly answer all questions to authenticate.

**Use cases:**

- Account recovery when other factors are unavailable
- Password reset verification
- Step-up authentication for account changes
- Identity verification for customer support interactions

```typescript
async function startKba(userId: string) {
  try {
    const challenge = await idaas.auth.kba(userId);

    // Show challenge.kbaChallenge.userQuestions to the user
    const answers = collectKbaAnswersFromForm(); // e.g., ["Fluffy", "Lincoln Elementary"]

    const final = await idaas.auth.submit({ kbaChallengeAnswers: answers });
    if (final.authenticationCompleted) {
      console.log("KBA passed!");
    }
  } catch (error) {
    console.error("KBA authentication failed", error);
  }
}
```

---

## Temporary access code

**Description:** Temporary access codes are one-time codes generated by administrators to grant users temporary access to their accounts. Typically used when users have lost access to their authentication factors or for initial account provisioning.

**Use cases:**

- Account recovery when all other factors are lost
- Initial account setup before primary authenticators are configured
- Emergency access granted by help desk administrators
- Onboarding new users in controlled environments

```typescript
async function startTempAccessCode(userId: string) {
  try {
    const code = (document.getElementById("temp-code") as HTMLInputElement).value;

    const final = await idaas.auth.tempAccessCode(userId, code);

    if (final.authenticationCompleted) {
      console.log("Temporary access code accepted!");
    }
  } catch (error) {
    console.error("Temporary access code failed", error);
  }
}
```

---

## Magic link

**Description:** Magic link authentication sends a one-time authentication link to the user's registered email address. Clicking the link authenticates the user without requiring a password. The link is time-limited and single-use for security.

**Use cases:**

- Passwordless authentication with email as the trust anchor
- Simplified login flow for low-security applications
- Temporary access for guest users
- Quick authentication on trusted devices

```typescript
async function startMagicLink(userId: string) {
  try {
    const initial = await idaas.auth.magicLink(userId);

    if (initial.authenticationCompleted) {
      console.log("Magic link redeemed!");
    }
  } catch (error) {
    console.error("Magic link failed", error);
  }
}
```

---

## Smart Credential push

**Description:** Smart Credential push authentication sends rich push notifications to the user's mobile device with transaction context (e.g., "Approve wire transfer of $10,000"). Users can review transaction details before approving or denying. Supports custom push message templates.

**Use cases:**

- High-value transaction approval (wire transfers, large purchases)
- Contextual authentication with transaction visibility
- Risk-based authentication requiring explicit user consent
- Scenarios requiring audit trail of user approval decisions

```typescript
async function startSmartCredential(userId: string) {
  try {
    const initial = await idaas.auth.smartCredential(userId, {
      summary: "Approve login to Example App",
      pushMessageIdentifier: "example-app-login"
    });

    if (initial.authenticationCompleted) {
      console.log("Smart Credential approved!");
    }
  } catch (error) {
    console.error("Smart Credential push failed", error);
  }
}
```

---

## Face biometrics (Onfido)

**Description:** Face biometric authentication uses Onfido's facial recognition technology to verify user identity through live facial capture. Includes liveness detection to prevent spoofing attacks with photos or videos. Requires the `onfido-sdk-ui` peer dependency.

**Use cases:**

- Identity verification during account registration
- High-security authentication requiring biometric proof of presence
- Remote identity proofing for regulated industries (financial services, healthcare)
- Step-up authentication for sensitive account changes

```typescript
import Onfido from "onfido-sdk-ui";
// ensure <div id="onfido-mount"></div> exists
async function startFace(userId: string) {
  try {
    const initial = await idaas.auth.faceBiometric(userId, {
      mutualChallenge: true
    });

    if (initial.authenticationCompleted) {
      console.log("Face verification succeeded!");
    }
  } catch (error) {
    console.error("Face authentication failed", error);
  }
}
```

> Install the optional dependency: `npm install onfido-sdk-ui`. Refer to the [Onfido Web SDK documentation](https://documentation.onfido.com/sdk/web/) for UI and capture details.

---

## Next steps

- Dive into the [Risk-Based Authentication Guide](guides/rba.md) for lower-level control.
- Consult the [API Reference](api/README.md) for method signatures.
- Check [Troubleshooting](troubleshooting.md) for common issues.
